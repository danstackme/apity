import { glob } from "glob";
import * as path from "path";
import * as fs from "fs/promises";
import { fileURLToPath } from "url";
import { parse } from "@babel/parser";
import traverse from "@babel/traverse";
import { Node } from "@babel/types";

// Handle both ESM and CJS environments
const traverseFn =
  typeof traverse === "function" ? traverse : (traverse as any).default;

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const ROOT_DIR = process.cwd();

type RouteConfig = {
  pattern: string;
  outputPath: string;
  outputType: string;
  ignore?: string[];
  baseDir: string;
};

const ROUTE_CONFIGS: RouteConfig[] = [
  {
    pattern: "src/endpoints/**/*.{ts,tsx}",
    outputPath: "src/generated/apiTree.gen.ts",
    outputType: "ApiTree",
    ignore: ["**/*.test.*", "**/*.spec.*"],
    baseDir: "src/endpoints",
  },
];

type EndpointDefinition = {
  method: string;
  response: string;
  body?: string;
  params?: string;
  query?: string;
};

function extractZodSchemaType(node: Node): string {
  if (
    node.type === "CallExpression" &&
    node.callee.type === "MemberExpression" &&
    node.callee.object.type === "Identifier" &&
    node.callee.object.name === "z"
  ) {
    if (node.callee.property.type === "Identifier") {
      if (node.callee.property.name === "object") {
        const properties = (node.arguments[0] as any).properties.map(
          (prop: any) => {
            const key = prop.key.name;
            const value = extractZodSchemaType(prop.value);
            return `${key}: ${value}`;
          }
        );
        return `{ ${properties.join("; ")} }`;
      } else if (node.callee.property.name === "array") {
        const elementType = extractZodSchemaType(node.arguments[0] as Node);
        return `${elementType}[]`;
      } else if (node.callee.property.name === "string") {
        return "string";
      } else if (node.callee.property.name === "number") {
        return "number";
      } else if (node.callee.property.name === "boolean") {
        return "boolean";
      }
    }
  }
  return "any";
}

async function parseEndpointFile(
  filePath: string
): Promise<Map<string, EndpointDefinition>> {
  const content = await fs.readFile(filePath, "utf-8");
  const ast = parse(content, {
    sourceType: "module",
    plugins: ["typescript"],
  });

  const endpoints = new Map<string, EndpointDefinition>();

  traverseFn(ast as any, {
    ExportNamedDeclaration(path: any) {
      const declaration = path.node.declaration;
      if (
        declaration?.type === "VariableDeclaration" &&
        declaration.declarations[0]?.init?.type === "CallExpression" &&
        declaration.declarations[0]?.init?.callee?.type === "Identifier" &&
        declaration.declarations[0]?.init?.callee?.name === "createApiEndpoint"
      ) {
        const name = (declaration.declarations[0].id as any).name;
        const config = declaration.declarations[0].init.arguments[0];

        const endpoint: EndpointDefinition = {
          method: config.properties.find((p: any) => p.key.name === "method")
            ?.value?.value,
          response: "any",
          body: undefined,
          params: undefined,
          query: undefined,
        };

        config.properties.forEach((prop: any) => {
          if (prop.key.name === "responseSchema") {
            endpoint.response = extractZodSchemaType(prop.value);
          } else if (prop.key.name === "bodySchema") {
            endpoint.body = extractZodSchemaType(prop.value);
          } else if (prop.key.name === "paramSchema") {
            endpoint.params = extractZodSchemaType(prop.value);
          } else if (prop.key.name === "querySchema") {
            endpoint.query = extractZodSchemaType(prop.value);
          }
        });

        endpoints.set(name, endpoint);
      }
    },
  });

  return endpoints;
}

async function generateApiTypes(config: RouteConfig) {
  const files = await glob(config.pattern, {
    cwd: ROOT_DIR,
    ignore: config.ignore,
  });

  console.log("[apity] Found files:", files);

  let output = `// Generated by @danstackme/apity
// Do not edit this file manually

import { ApiEndpoint } from "@danstackme/apity";

`;

  const routes = new Map<string, Map<string, EndpointDefinition>>();

  // Process route files
  for (const file of files) {
    console.log("[apity] Processing file:", file);
    const endpoints = await parseEndpointFile(path.join(ROOT_DIR, file));

    const routePath = path
      .relative(config.baseDir, file)
      .replace(/\.(ts|tsx)$/, "")
      .replace(/\\/g, "/");

    const apiPath = "/" + routePath.split("/").filter(Boolean).join("/");
    routes.set(apiPath, endpoints);
  }

  // Generate interface definitions
  for (const [path, endpoints] of routes) {
    for (const [method, endpoint] of endpoints) {
      const interfaceName = `${path.replace(/\W+/g, "_")}_${method}`;

      if (endpoint.body) {
        output += `interface ${interfaceName}_Body ${endpoint.body}\n\n`;
      }
      if (endpoint.params) {
        output += `interface ${interfaceName}_Params ${endpoint.params}\n\n`;
      }
      if (endpoint.query) {
        output += `interface ${interfaceName}_Query ${endpoint.query}\n\n`;
      }
    }
  }

  // Generate API tree type
  output += `export type ${config.outputType} = {\n`;
  for (const [path, endpoints] of routes) {
    const displayPath = path.replace(/\/index$/, "");
    output += `  "${displayPath}": {\n`;

    for (const [method, endpoint] of endpoints) {
      const interfaceName = `${path.replace(/\W+/g, "_")}_${method}`;
      output += `    ${method}: ApiEndpoint<\n`;
      output += `      ${endpoint.response},\n`;
      output += `      ${endpoint.body ? `${interfaceName}_Body` : "never"},\n`;
      output += `      ${endpoint.query ? `${interfaceName}_Query` : "never"},\n`;
      output += `      ${endpoint.params ? `${interfaceName}_Params` : "never"}\n`;
      output += `    >;\n`;
    }

    output += `  };\n`;
  }
  output += "};\n";

  // Create the generated directory if it doesn't exist
  const outputDir = path.dirname(path.join(ROOT_DIR, config.outputPath));
  await fs.mkdir(outputDir, { recursive: true });

  // Write the generated file
  await fs.writeFile(path.join(ROOT_DIR, config.outputPath), output);

  console.log("[apity] Generated API types");
}

async function generateTypes() {
  for (const config of ROUTE_CONFIGS) {
    await generateApiTypes(config);
  }
}

export { generateTypes };

// Only run if this is the main module
if (process.argv[1] === path.resolve(__dirname, "generate.js")) {
  generateTypes().catch(console.error);
}
